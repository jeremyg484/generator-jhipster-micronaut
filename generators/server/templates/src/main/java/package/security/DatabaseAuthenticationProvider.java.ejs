package <%=packageName%>.security;

import <%=packageName%>.domain.Authority;
import <%=packageName%>.domain.User;
import <%=packageName%>.repository.UserRepository;
import edu.umd.cs.findbugs.annotations.Nullable;
import io.micronaut.http.HttpRequest;
import io.micronaut.scheduling.TaskExecutors;
import io.micronaut.security.authentication.AuthenticationProvider;
import io.micronaut.security.authentication.AuthenticationRequest;
import io.micronaut.security.authentication.AuthenticationResponse;
import io.micronaut.security.authentication.UserDetails;
import io.reactivex.BackpressureStrategy;
import io.reactivex.Flowable;
import io.reactivex.Scheduler;
import io.reactivex.schedulers.Schedulers;

import org.reactivestreams.Publisher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Named;
import javax.inject.Singleton;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.concurrent.ExecutorService;
import java.util.stream.Collectors;

@Singleton
public class DatabaseAuthenticationProvider implements AuthenticationProvider {

    private final Logger log = LoggerFactory.getLogger(DatabaseAuthenticationProvider.class);

    private static final NotAuthenticatedResponse BAD_ATTEMPT = new NotAuthenticatedResponse("Invalid username or password");

    private final Scheduler scheduler;
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public DatabaseAuthenticationProvider(@Named(TaskExecutors.IO) ExecutorService executorService, UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.scheduler = Schedulers.from(executorService);
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public Publisher<AuthenticationResponse> authenticate(@Nullable HttpRequest<?> httpRequest, AuthenticationRequest<?, ?> authenticationRequest) {
        String username = authenticationRequest.getIdentity().toString();

        log.debug("Authenticating {}", username);

        String lowercaseLogin = username.toLowerCase(Locale.ENGLISH);
        return Flowable.<AuthenticationResponse>create(emitter -> {
            Optional<AuthenticationResponse> result = userRepository.findOneByEmailEqualsOrLoginEquals(username, lowercaseLogin)
                .filter(user -> passwordEncoder.matches(authenticationRequest.getSecret().toString(), user.getPassword()))
                .map(user -> createMicronautSecurityUser(lowercaseLogin, user));

            if (result.isPresent()) {
                emitter.onNext(result.get());
            } else {
                emitter.onNext(BAD_ATTEMPT);
            }

            emitter.onComplete();
        }, BackpressureStrategy.ERROR).subscribeOn(scheduler);
    }

    private AuthenticationResponse createMicronautSecurityUser(String lowercaseLogin, User user) {
        if (!user.getActivated()) {
            return new NotAuthenticatedResponse("User " + lowercaseLogin + " was not activated");
        }
        List<String> grantedAuthorities = user.getAuthorities().stream()
            .map(Authority::getName)
            .collect(Collectors.toList());

        return new UserDetails(user.getLogin(), grantedAuthorities);
    }
}
